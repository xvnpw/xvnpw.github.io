<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SSRF on xvnpw personal blog</title><link>https://xvnpw.github.io/tags/ssrf/</link><description>Recent content in SSRF on xvnpw personal blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 Jul 2020 10:14:47 +0100</lastBuildDate><atom:link href="https://xvnpw.github.io/tags/ssrf/index.xml" rel="self" type="application/rss+xml"/><item><title>From . in regex to SSRF - part 3</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-3/</link><pubDate>Tue, 07 Jul 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-3/</guid><description>&lt;p>This is last part of my stories about exploiting service with SSRF bug. Part 1 is available &lt;a class="link" href="https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/" >here&lt;/a>, and part 2 &lt;a class="link" href="https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-2/" >here&lt;/a>.&lt;/p>
&lt;p>This part is focused on abusing Node.js and &lt;em>node-fetch&lt;/em> library. I will try to &amp;ldquo;talk&amp;rdquo; with Redis service using CRLF injection in http parser.&lt;/p>
&lt;p>For convenience Redis service will be simulated by &lt;code>nc -vvlp 6379&lt;/code>.&lt;/p>
&lt;p>Test environment from my Kali 2020.1b:&lt;/p>
&lt;ul>
&lt;li>Node.js version 10.19.0&lt;/li>
&lt;li>node-fetch version 2.6.0&lt;/li>
&lt;/ul>
&lt;h2 id="crlf-injection">CRLF Injection&lt;/h2>
&lt;p>Lets start with PayloadsAllTheThings. It contains couple of CRLF Injection payloads. I will loop over them and check result in second console:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139583089-ecf56f8e-5c1a-465d-b0ff-01204ef313aa.png"/>
&lt;/figure>
&lt;p>None success here. All payloads failed 🙁&lt;/p>
&lt;p>Next step is to check payloads from two great articles by Orange Tsai: &lt;a class="link" href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf" target="_blank" rel="noopener"
>first from Red Hat 2017&lt;/a> and &lt;a class="link" href="https://blog.orange.tw/2017/07/how-i-chained-4-vulnerabilities-on.html" target="_blank" rel="noopener"
>second from his blog&lt;/a>. It&amp;rsquo;s giving few more options to test:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">－＊Set-Cookie:injection－＊ (Unicode U+FF0D U+FF0A)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">http://0\r\n SET foo 0 60 5\r\n :6379/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">https://0\r\nSET foo 0 60 5\r\n:6379/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Still no success here. I seams that this version of Node.js is not vulnerable for CRLF attacks.&lt;/p>
&lt;p>Let&amp;rsquo;s try harder and dig dipper into node-fetch, maybe something interesting will be in code 😃&lt;/p>
&lt;h2 id="investigation-of-node-fetch-code">Investigation of node-fetch code&lt;/h2>
&lt;p>What am I trying to achieve here? I have in mind two types of possible errors:&lt;/p>
&lt;ol>
&lt;li>Url parsing&lt;/li>
&lt;li>Handling url input as object not as &lt;em>string&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Let&amp;rsquo;s see what I will find.&lt;/p>
&lt;p>Debug of Node.js code is quite nice with Visual Studio Code:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139583200-2686e457-092e-4385-8a01-f7716babf711.png"/>
&lt;/figure>
&lt;p>Problem number one is not existing as node-fetch is using standard Node.js &lt;code>Url.parse&lt;/code> for input. There are not doing much fancy stuff with it.&lt;/p>
&lt;p>For second problem I needed to do more investigation.&lt;/p>
&lt;p>First of all I will explain why I&amp;rsquo;m interested in processing &lt;em>object&lt;/em> instead of &lt;em>string&lt;/em>. In many dynamic languages you can make valid request like this:&lt;/p>
&lt;p>&lt;code>http://localhost:3000/c?url[href]=localhost&amp;amp;url[method]=POST&lt;/code>&lt;/p>
&lt;p>This leads to created object instead of string. Could be quite handy for some scenarios. Especially if developers didn&amp;rsquo;t predict it 😃 See below example of parsing such url in Node.js Express framework.&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139583272-0e1f3070-7ec9-44a3-8df7-ac9cf858d883.png"/>
&lt;/figure>
&lt;p>In node-fetch I have found one possible attacking vector:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139583293-12f60351-0548-41c5-a92b-45711eac279f.png"/>
&lt;/figure>
&lt;p>It look like possible to use object instead of string for input parameter. This &lt;code>input.method&lt;/code> could change method type in some specific conditions. After spending some time in debugger it turn out as &lt;strong>dead end&lt;/strong>.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>I didn&amp;rsquo;t manage to escalate blind SSRF to anything more. I have spent couple of days trying different approaches. Nevertheless after submitting report I was awarded with &lt;strong>400$&lt;/strong> and bug was marked as &lt;strong>medium&lt;/strong>.&lt;/p>
&lt;hr>
&lt;p>Thanks for reading! You can follow me on &lt;a class="link" href="https://twitter.com/xvnpw" target="_blank" rel="noopener"
>Twitter&lt;/a>.&lt;/p></description></item><item><title>From . in regex to SSRF - part 2</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-2/</link><pubDate>Tue, 14 Jan 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-2/</guid><description>&lt;p>In this story I will continue my journey to exploit Server Side Request Forgery (SSRF). Part 1 is available &lt;a class="link" href="https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/" >here&lt;/a>.&lt;/p>
&lt;p>What is state of the game up to now? I have found service that is vulnerable to SSRF by executing the REST call and by passing domain name check:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/https://www-example.org&lt;/code>&lt;/p>
&lt;p>I have registered domain name: &lt;code>www-example.org&lt;/code> and add for it &lt;code>CNAME&lt;/code> record to my EC2 server.&lt;/p>
&lt;p>But wait a second. &lt;strong>This is not yet &amp;ldquo;SSRF&amp;rdquo;&lt;/strong>. For now I could call specific domain, but didn&amp;rsquo;t prove ability to scan internal ports or execute requests to internal services.&lt;/p>
&lt;p>First of all I checked what headers are sent to my server:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">nc -l -n -p &lt;span class="m">80&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139582215-1ead26ed-3b56-4ff7-9e25-35d901c27653.png"/>
&lt;/figure>
&lt;p>What it interesting here is &lt;code>User-Agent&lt;/code>. Clearly indicating &lt;strong>NodeJS&lt;/strong> and &lt;strong>node-fetch&lt;/strong> library.&lt;/p>
&lt;h2 id="tools">Tools&lt;/h2>
&lt;p>For this part I needed http server to host some files and do redirects. Here is my script based on python &lt;code>http.server&lt;/code>:&lt;/p>
&lt;script type="application/javascript" src="https://gist.github.com/xvnpw/9fa7f7c5a7dfa13d3f27d2e19af9a264.js">&lt;/script>
&lt;p>This script is doing two things:&lt;/p>
&lt;ul>
&lt;li>if request is starting with query parameter &lt;code>/?r=&lt;/code> it is taking value of this parameter and put it in &lt;code>Location&lt;/code> header, returning code &lt;code>302&lt;/code>&lt;/li>
&lt;li>else it is loading file from disk and always returning &lt;code>image/svg+xml&lt;/code> with code &lt;code>200&lt;/code>. &lt;strong>This is important!&lt;/strong> Always return expected &lt;code>Content-Type&lt;/code> to check if parser can handle different types.&lt;/li>
&lt;/ul>
&lt;p>This code is PoC so don&amp;rsquo;t expect much out of it. It&amp;rsquo;s for testing purpose only. &lt;code>Don't use it on production&lt;/code>.&lt;/p>
&lt;p>You can check more of my hacking resources in &lt;a class="link" href="https://github.com/xvnpw/hacking" target="_blank" rel="noopener"
>my public repo&lt;/a>.&lt;/p>
&lt;h2 id="mind-map">Mind map&lt;/h2>
&lt;p>Here is mind map of ideas that I had during exploitation:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139582537-5fe5ba0c-123f-4413-8a0f-9f90194a5415.png"/>
&lt;/figure>
&lt;h2 id="svg-payload">SVG payload&lt;/h2>
&lt;p>Hosting some svg files was my first shot. I have took some from PayloadsAllTheThings repository, but sadly none was working.&lt;/p>
&lt;p>In most cases I got &lt;code>502 Bad Gateway&lt;/code> and in some payloads were just ignored. The other thing I noticed is that I was able request &lt;code>png&lt;/code> or &lt;code>jpg&lt;/code> file and it was parsed. I have gut feeling that service was using some kind of NodeJS library, not ImageMagick. Maybe I did miss something?&lt;/p>
&lt;h2 id="http-redirect">HTTP Redirect&lt;/h2>
&lt;p>I have implemented in my &lt;code>server.py&lt;/code> possibility to redirect with new &lt;code>Location&lt;/code> header. This created variety of options to exploit.&lt;/p>
&lt;p>Lets start with ports scanning:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/https://www-example.org/%3Fr%3Dhttp%3A%2F%2F127.0.0.1%3A80%2F&lt;/code>&lt;/p>
&lt;p>Redirect part is url encoded to not break service with &lt;code>?&lt;/code> or &lt;code>/&lt;/code>. I have taken this to Burp Intruder and scan all ports. But if you are using free version of Burp this can take a very long time. So it&amp;rsquo;s better to use &lt;code>ffuf&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> i in &lt;span class="o">{&lt;/span>1..65535&lt;span class="o">}&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="nv">$i&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">done&lt;/span> &amp;gt; all_ports.txt&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ffuf -mc all -ac -w all_ports.txt -u &lt;span class="s1">&amp;#39;https://api.example.org/image-converter/https://www-example.org/%3Fr%3Dhttp%3A%2F%2F127.0.0.1%3AFUZZ%2F&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Same way I was able to &lt;strong>scan for internal services&lt;/strong>. For list of domains I used SecLists:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">ffuf -mc all -ac -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u &lt;span class="s1">&amp;#39;https://api.example.org/image-converter/https://www-example.org/%3Fr%3Dhttp%3A%2F%2FFUZZ.example.org%2F&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>This will try to make a call to subdomains of &lt;code>example.org&lt;/code> but from perspective of &lt;code>api.example.org&lt;/code>. In my case it found redis instance on &lt;code>redis.example.org&lt;/code>.&lt;/p>
&lt;p>Next step for me was &lt;strong>access cloud resources&lt;/strong>, e.g. metadata services on 169.254.169.254:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/https://www-example.org/%3Fr%3Dhttp%3A%2F%2F169.254.169.254%3A80%2F&lt;/code>&lt;/p>
&lt;p>I was able to positively connect to 169.254.169.254. So it means that service was running on AWS.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>I finally got blind SSRF using redirect &lt;code>302&lt;/code> code and &lt;code>Location&lt;/code> header! That&amp;rsquo;s gave me possibility to penetrate internal network. I was disappointed that no svg payload was working. For part 3 I left &amp;ldquo;HTTP Parser Abuse&amp;rdquo; - I will try to force node-fetch to change protocol and talk with services like &lt;code>redis&lt;/code>.&lt;/p>
&lt;hr>
&lt;p>Thanks for reading! You can follow me on &lt;a class="link" href="https://twitter.com/xvnpw" target="_blank" rel="noopener"
>Twitter&lt;/a>.&lt;/p></description></item><item><title>From . in regex to SSRF - part 1</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/</link><pubDate>Sun, 05 Jan 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/</guid><description>&lt;figure class="image-center">&lt;img src="https://user-images.githubusercontent.com/17719543/139576912-865d0f16-6dc3-4af9-8a39-5e77d7b236c3.png"/>
&lt;/figure>
&lt;p>In test of one application I have encountered bug in regex that leaded to Server Side Request Forgery (SSRF). Way of finding it was huge fun and excitement. It was also my first bug on production system ever.&lt;/p>
&lt;p>During a recon I have found service called &lt;em>image-converter&lt;/em>. It was definitely interesting, but not straight forward to exploit. I had no example of usage it and on simple GET request I was just getting:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139576933-06cadc0d-6489-4ac1-8e58-292d5fb1baf8.png"/>
&lt;/figure>
&lt;p>That was first major problem for me. I was trying with some simple query parameters like:&lt;/p>
&lt;ul>
&lt;li>&lt;code>?url=&lt;/code>&lt;/li>
&lt;li>&lt;code>?width=&lt;/code>&lt;/li>
&lt;li>&lt;code>?name=&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>and so on but without luck. Then I tried with &lt;a class="link" href="https://github.com/s0md3v/Arjun" target="_blank" rel="noopener"
>https://github.com/s0md3v/Arjun&lt;/a> which is tool for automated parameter discovery. This also failed. I was pretty sure that there is something out there, but I couldn&amp;rsquo;t force it to work.&lt;/p>
&lt;p>Then I started digging in what is this error message that I see all the time: &lt;code>&amp;quot;Cannot read property 'groups' of null&amp;quot;&lt;/code>. This leads me to stackoverflow question about JavaScript and regex error. After that I was wondering: &amp;ldquo;How the hell they have implemented this?&amp;rdquo;. After hour of trying and failure, I got it:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/width=100/http://google.com&lt;/code>&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139577018-2487fddb-ef0a-449b-a893-7ad929e4aa0b.png"/>
&lt;/figure>
&lt;p>In my almost 10 years IT career, I didn&amp;rsquo;t see service implementation like that 😉&lt;/p>
&lt;p>My positive energy went down, as I realized that there is domain whitelisting implemented. I have picked main domain &lt;code>www.example.org&lt;/code> and in fact it was working:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/width=100/https://www.example.org&lt;/code>&lt;/p>
&lt;p>I got response:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139577079-083fd93f-3679-4487-9f91-4d7f8fec6be8.png"/>
&lt;/figure>
&lt;p>In this moment I was sure about SSRF, but still had whitelisting to bypass.&lt;/p>
&lt;p>My first approach was to take SSRF from &lt;a class="link" href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery" target="_blank" rel="noopener"
>PayloadAllTheThings&lt;/a> and test it. I don&amp;rsquo;t want to copy all that here. There is dozen of payloads. Sadly not of it worked. I got very interested in &lt;a class="link" href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf" target="_blank" rel="noopener"
>Orange: A New Era SSRF&lt;/a>, but that was also death end.&lt;/p>
&lt;p>I was pretty puzzled. Having high hope on some nice bug, but it looked like this service was secured. Good thing was that I have learned a lot, especially from Orange paper.&lt;/p>
&lt;p>Next day with fresh head I took different way. During recon I have noted two other domains connected with main one: &lt;code>www.example.net&lt;/code> and &lt;code>www.example.com&lt;/code>. It turn out that those domains where also whitelisted. Having a background in programming I knew that developers have a tendency to write &amp;ldquo;nice code&amp;rdquo;, so maybe they used regex to check domain suffix? And guess what? They did! For request:&lt;/p>
&lt;p>&lt;code>https://api.example.org/image-converter/width=100/https://www-example.org&lt;/code>&lt;/p>
&lt;p>I got response:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139577185-1b2711fb-6a19-435e-8bd3-015deb803884.png"/>
&lt;/figure>
&lt;p>Hurray!&lt;/p>
&lt;p>What exactly regex they used ? I think something like this regex101:&lt;/p>
&lt;figure>&lt;img src="https://user-images.githubusercontent.com/17719543/139577198-3c7995e4-d9ef-4c83-ad57-2608c17305ed.png"/>
&lt;/figure>
&lt;p>And what they should use is: &lt;code>www\.example\.(com|net|org)&lt;/code>&lt;/p>
&lt;p>Next I have registered &lt;code>www-example.com&lt;/code> domain and started playing with escalation this. More about it in part 2.&lt;/p>
&lt;hr>
&lt;p>Thanks for reading! You can follow me on &lt;a class="link" href="https://twitter.com/xvnpw" target="_blank" rel="noopener"
>Twitter&lt;/a>.&lt;/p></description></item></channel></rss>