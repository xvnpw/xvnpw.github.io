<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on xvnpw personal blog</title><link>https://xvnpw.github.io/posts/</link><description>Recent content in Posts on xvnpw personal blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 29 Jul 2023 18:59:02 +0100</lastBuildDate><atom:link href="https://xvnpw.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Mitigating SSRF vulnerabilities in Go. A practical guide. Part 1</title><link>https://xvnpw.github.io/posts/mitigating_ssrf_vulnerabilities_in_go_a_practical_guide_part_1/</link><pubDate>Sat, 29 Jul 2023 18:59:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/mitigating_ssrf_vulnerabilities_in_go_a_practical_guide_part_1/</guid><description>Server-Side Request Forgery (SSRF) vulnerabilities have been around for a long time, and they still pose a significant threat to web applications, so much so this kind of vulnerability has been included in OWASP TOP 10. This type of attack allows an attacker to send unauthorized requests from a vulnerable application, which can lead to data leakage, server-side request smuggling, and even full-scale remote code execution.
Basic example of SSRF in Go Let&amp;rsquo;s see basic code that introduce this vulnerability:</description></item><item><title>Threat Modeling 101</title><link>https://xvnpw.github.io/posts/threat_modeling_101/</link><pubDate>Wed, 19 Oct 2022 18:59:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/threat_modeling_101/</guid><description>What is Threat Modeling? First of all, it&amp;rsquo;s just thinking about threats. We all do it, every day üòÉ &amp;ldquo;How someone could break into my house?&amp;rdquo; But wait a second. How do you know that you need to protect your house in the first place? Maybe you don&amp;rsquo;t have a house, or maybe you don&amp;rsquo;t have money right now to buy deterrents. Or maybe your family thinks you are a bit paranoid?</description></item><item><title>External Authentication bypass in ingress-nginx</title><link>https://xvnpw.github.io/posts/external_authentication_bypass_in_ingress_nginx/</link><pubDate>Sun, 29 May 2022 16:59:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/external_authentication_bypass_in_ingress_nginx/</guid><description>In October 2021 I was researched ingress-nginx for possibility to bypass external authentication using path traversal. It was origin story for other investigations regarding insecure usage of $request_uri which leaded to Apache APISIX CVE-2021-43557. I have started with report on HackerOne to Kubernetes project: https://hackerone.com/reports/1357948. It took long time for the team to investigate it, but in the end I got some bounty üòè sadly report was closed as informative.</description></item><item><title>Hunting for buggy authentication/authorization services on github</title><link>https://xvnpw.github.io/posts/hunting_for_buggy_authentication_authorization_services_on_github/</link><pubDate>Sun, 28 Nov 2021 10:58:59 +0100</pubDate><guid>https://xvnpw.github.io/posts/hunting_for_buggy_authentication_authorization_services_on_github/</guid><description>To successful bypass access control using path traversal in $request_uri, you need to have buggy authentication/authorization service. Buggy in a way it&amp;rsquo;s not normalizing url/uri that is part of access control decision. Let me find more of those on github that are relying on X-Original-Url. There is high chance that this header is populated from $request_uri variable and not protected in any way.
pomerium Pomerium is an identity-aware proxy that enables secure access to internal applications.</description></item><item><title>Bug bounty tips for nginx $request_uri path traversal bypass</title><link>https://xvnpw.github.io/posts/bug_bounty_tips_for_nginx_request_uri_path_traversal_bypass/</link><pubDate>Sat, 27 Nov 2021 22:59:05 +0100</pubDate><guid>https://xvnpw.github.io/posts/bug_bounty_tips_for_nginx_request_uri_path_traversal_bypass/</guid><description>In this article, I will extend topic by bug bounty tips for weaknesses in authentication/authorization implementation in relation to nginx&amp;rsquo;s $request_uri variable.
APIs This vulnerability is for APIs. Best scenario are microservice deployed to Kubernetes and exposed by ingress controller.
Using paths API that you are playing with, need to use paths to address services, e.g.:
OK! https://api.example.com/user-service https://api.example.com/customer-service ... NOT OK! https://user.example.com/ https://customer.example.com/ First set of URLs is good for exploitation, as you can try sending request with https://api.</description></item><item><title>Path traversal in authorization context in Kong and F5 NGINX</title><link>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_kong_and_f5_nginx/</link><pubDate>Thu, 25 Nov 2021 20:49:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_kong_and_f5_nginx/</guid><description>In this part I will research another ingress controller based on nginx: ü¶ç kong. At the end of article I will mention in short F5 NGINX Ingress Controller.
In kong there is no explicit feature called external authentication, but developers gave possibility to create it using plugins.
Here are some links describing this process:
Custom Authentication and Authorization Framework with Kong aunkenlabs/kong-external-auth - repository with PoC of external-auth. It&amp;rsquo;s old and cannot be run as it with kong 2.</description></item><item><title>Path traversal in authorization context in Emissary</title><link>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_emissary/</link><pubDate>Wed, 24 Nov 2021 19:59:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_emissary/</guid><description>After checking Apache APISIX and Traefik, for path traversal in authZ context, now I will research Emissary ingress.
In Emissary there is feature called Basic authentication, which is very similar to forward authentication discussed in Traefik.
Emissary-ingress can authenticate incoming requests before routing them to a backing service.
I can already tell you that Emissary is secure and you cannot bypass using path traversal. What is even better, it&amp;rsquo;s (and envoy) aware of this kind of security concern.</description></item><item><title>Path traversal in authorization context in Traefik and HAProxy</title><link>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_traefik_and_haproxy/</link><pubDate>Tue, 23 Nov 2021 22:38:58 +0100</pubDate><guid>https://xvnpw.github.io/posts/path_traversal_in_authorization_context_in_traefik_and_haproxy/</guid><description>In my previous post about Apache APISIX I have found path traversal in uri-blocker plugin. In this text I will focus on yet another ingress controller which is Traefik. It has feature called forward auth. At the end I will mention HAProxy ingress controller.
From docs:
The ForwardAuth middleware delegate the authentication to an external service. If the service response code is 2XX, access is granted and the original request is performed.</description></item><item><title>CVE-2021-43557: Apache APISIX: Path traversal in request_uri variable</title><link>https://xvnpw.github.io/posts/cve_2021_43557_apache_apisix_path_traversal_in_request_uri_variable/</link><pubDate>Mon, 22 Nov 2021 20:59:02 +0100</pubDate><guid>https://xvnpw.github.io/posts/cve_2021_43557_apache_apisix_path_traversal_in_request_uri_variable/</guid><description>In this article I will present my research on insecure usage of $request_uri variable in Apache APISIX ingress controller. My work end up in submit of security vulnerability, which was positively confirmed and got CVE-2021-43557. At the end of article I will mention in short Skipper which I tested for same problem.
What is APISIX ? From official website:
Apache APISIX is a dynamic, real-time, high-performance API gateway. APISIX provides rich traffic management features such as load balancing, dynamic upstream, canary release, circuit breaking, authentication, observability, and more.</description></item><item><title>Azure subscription security¬†review</title><link>https://xvnpw.github.io/posts/azure-subscription-security-review/</link><pubDate>Mon, 01 Feb 2021 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/azure-subscription-security-review/</guid><description>{{ template &amp;ldquo;_internal/google_analytics.html&amp;rdquo; . }}
Lately I have come across task to perform security review of Azure subscription. It was white-box based and I had access to all terraform, Kubernetes and Docker files. I will share with you what checks are worth to do for such review.
My methodology Number of resources to check may vary from project to project. For me best approach is to mix automated tools with manual work.</description></item><item><title>Hacking SpEL</title><link>https://xvnpw.github.io/posts/hacking-spel/</link><pubDate>Fri, 17 Jul 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/hacking-spel/</guid><description>This story will explain how to find and exploit SpEL parser in web applications based on Java language.
What is SpEL¬†? From Spring documentation:
The Spring Expression Language (SpEL for short) is a powerful expression language that supports querying and manipulating an object graph at runtime.
Where is it used¬†?
Spring Framework: Security, Data,¬†‚Ä¶ Any place developers use it by SpEL API For languages it can be used in Java, Kotlin, Scala, and other JVM based technologies.</description></item><item><title>From . in regex to SSRF‚Ää-‚Ääpart 3</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-3/</link><pubDate>Tue, 07 Jul 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-3/</guid><description>This is last part of my stories about exploiting service with SSRF bug. Part 1 is available here, and part 2 here.
This part is focused on abusing Node.js and node-fetch library. I will try to &amp;ldquo;talk&amp;rdquo; with Redis service using CRLF injection in http parser.
For convenience Redis service will be simulated by nc -vvlp 6379.
Test environment from my Kali 2020.1b:
Node.js version 10.19.0 node-fetch version 2.6.0 CRLF Injection Lets start with PayloadsAllTheThings.</description></item><item><title>From¬†. in regex to SSRF‚Ää-‚Ääpart¬†2</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-2/</link><pubDate>Tue, 14 Jan 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-2/</guid><description>In this story I will continue my journey to exploit Server Side Request Forgery (SSRF). Part 1 is available here.
What is state of the game up to now? I have found service that is vulnerable to SSRF by executing the REST call and by passing domain name check:
https://api.example.org/image-converter/https://www-example.org
I have registered domain name: www-example.org and add for it CNAME record to my EC2 server.
But wait a second. This is not yet &amp;ldquo;SSRF&amp;rdquo;.</description></item><item><title>From¬†. in regex to SSRF‚Ää-‚Ääpart¬†1</title><link>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/</link><pubDate>Sun, 05 Jan 2020 10:14:47 +0100</pubDate><guid>https://xvnpw.github.io/posts/from-dot-in-regex-to-ssrf-part-1/</guid><description>In test of one application I have encountered bug in regex that leaded to Server Side Request Forgery (SSRF). Way of finding it was huge fun and excitement. It was also my first bug on production system ever.
During a recon I have found service called image-converter. It was definitely interesting, but not straight forward to exploit. I had no example of usage it and on simple GET request I was just getting:</description></item></channel></rss>